{"name":"Rails engines example","tagline":"","body":"# Rails Engines Example\r\n\r\nThis shows how to use engines for namespacing within a \"operator\" Rails application.\r\n_View original\r\n[post](http://tech.taskrabbit.com/blog/2014/02/11/rails-4-engines/)_.\r\n\r\n## Table of contents<a name=\"top\"></a>\r\n- [Rails Engines](#rails-engines)\r\n- [Versus Many Apps](#versus-many-apps)\r\n- [Versus Single App](#versus-single-app)\r\n- [Engine Usage](#engine-usage)\r\n- [Admin](#admin)\r\n- [Shared Code](#shared-code)\r\n- [API Server](#api-server)\r\n- [Strategies](#strategies)\r\n- [Migrations and Models](#migrations-and-models)\r\n- [Admin](#admin)\r\n- [Assets](#assets)\r\n- [Routes](#routes)\r\n- [Tests](#tests)\r\n- [Memory](#memory)\r\n- [Folders and Files](#folders-and-files)\r\n- [Interaction Between Engines](#interaction-between-engines)\r\n- [Summary](#summary)\r\n\r\n\r\nAt\r\n[TaskRabbit](https://www.taskrabbit.com),\r\nwe have gone through a few iterations on how we make our app(s). In the beginning, there was the monolithic Rails app in the standard way with 100+ models and their many corresponding controllers and views. Then we moved to several apps with their own logic and often using the big one via API. Our newest\r\n[project](https://taskrabbit.co.uk)\r\nis a single \"app\" made up of several Rails engines. We have found that this strikes a great balance between the (initial) straightforwardness of the single Rails app and the modularity of the more service-oriented architecture.\r\n\r\nWe've talked about this approach with a few people and they often ask very specific questions about the tactics used to make this happen, so let's go through it here and via a\r\n\r\n[sample application](https://github.com/taskrabbit/rails_engines_example).[back to top](#top)\r\n\r\n## Rails Engines <a name=\"rails-engines\"></a>\r\n\r\n[Rails Engines](http://edgeguides.rubyonrails.org/engines.html)\r\nis basically a whole Rails app that lives in the container of another one. Put another way, as the docs note: an app itself is basically just an engine at the root level. Over the years, we've seen engines as parts of gems such as\r\n[devise](https://github.com/plataformatec/devise/blob/7a9ae13baadc3643d0f5b74077d9760d19c56adb/lib/devise/rails.rb) or\r\n[rails_admin](https://github.com/sferik/rails_admin/blob/master/lib/rails_admin/engine.rb).\r\nThese example show the power of engines by providing a large set of relatively self-contained functionality \"mounted\" into an app.\r\n\r\nAt some point, there was a talk that suggested the approach of putting my our functionality into engines and that the Rails team seemed to be devoting more and more time to make them a first class citizen. Our friends at Pivotal Labs were talking about it a lot, too. Sometimes\r\n[good](http://pivotallabs.com/migrating-from-a-single-rails-app-to-a-suite-of-rails-engines/)\r\nand sometimes\r\n[not so good](http://pivotallabs.com/experience-report-engine-usage-that-didn-t-work/).\r\n\r\n[back to top](#top)\r\n\r\n## Versus Many Apps <a name=\"versus-many-apps\"></a>\r\n\r\nWe'd seen an app balloon and get out of control before, leading us to try and find better ways of modularization. It was fun and somewhat liberating to say \"Make a new app!\" when there was a new problem domain to tackle. We also used it as a way to handle our growing organization. We could ask Team A to work on App A and know that they could run faster by understanding the scope was limited to that. As a side-note and in retrospect, we probably let organizational factors affect architecture way more than appropriate.\r\n\r\nLots of things were great about this scenario. The teams had freedom to explore new approaches and we learned a lot. App B could upgrade Rack (or whatever) because it depended on the crazy thing that App A depended on. App C had the terrible native code-dependent gem and we only had to put that on the App C servers. Memory usage was kept lower, allowing us to run more background workers and unicorn threads.\r\n\r\nBut things got rough in coordinating across these apps. It wasn't just the data access. We made APIs and allowed any app to have read-only access to the platform app's database. This allowed things go much faster by preventing creation of many GET endpoints and possible points of failure. The main issue in coordinating releases that spanned apps is that they just went slower than if it was one codebase. There was also interminable bumping of gem versions to get shared code to all the apps. Integration testing the whole experience was also very rough.\r\n\r\nSo it's a simple one, but the main advantage that we've seen in the engine model is that it is one codebase and git repo. A single pull request has everything related to that feature. It rolls out atomically. Gems can be bumped once and our internal gems aren't bumped at all as they live unbuilt in a `gems` folder in the app itself. We still get most of the modularization that multiple apps had. For example, the User model in the payments engine has all the stuff about balances and the one in the profile engine doesn't know anything about all that and it's various helper methods.\r\n\r\nThe issue with gem upgrades and odd server configurations does continue to exist in the engine model and is mostly fine in the many app model. The gem one is tough and we just try to stay on top of upgrading to the newest things and overall reducing dependencies. The specs will also run slower in the engine app, but you'll have better integration testing. I'll go over a little bit about we've tackled server configurations and memory further down.\r\n\r\n[back to top](#top)\r\n\r\n## Versus Single App <a name=\"versus-single-app\"></a>\r\n\r\nIt's very tempting when green-fielding a project to just revert back to the good-old-days of the original app. Man, that was so nice back before the (too) fat models and tangled views and combinatorics of 4 years of iterating screwed things up. And we've learned a lot since then too, right? Especially about saying no to all those\r\n[combinatorics](http://firstround.com/article/The-one-cost-engineers-and-product-managers-dont-consider)\r\nand also using\r\n[decorators](http://robots.thoughtbot.com/tidy-views-and-beyond-with-decorators)\r\nand\r\n[service objects](http://adequate.io/culling-the-activerecord-lifecycle)\r\nand using\r\n[APIs](http://www.api-first.com/).\r\nMaybe.\r\n\r\nWhat we do know is that you can feel that way again even a year into an app. Inside any given engine, you have the scope of a much smaller project. Some engines may grow larger and you'll start to use those tools to keep things under control. Some will (correctly) have limited scope and feel like a simple app in which you understand everything that is happening. For example, decorators are great tool and they came in handy in our big app and larger engines. However, we've found in an a targeted engine that only serves its one purpose, it feels like there is room in that model to have some things that would have been decorated in a larger app. This is because it doesn't have all that other junk in it. Only this engine's junk :-)\r\n\r\n[back to top](#top)\r\n\r\n## Engine Usage <a name=\"engine-usage\"></a>\r\n\r\nWe've seen a few different ways to use engines in a Rails project. A few examples are below. The basic variables are what is in the \"operator\" (root) app and what kind of app we're making (API driven or not).\r\n\r\n[back to top](#top)\r\n\r\n### Admin <a name=\"admin\"></a>\r\n\r\nThe first engine we've recommend making to people is the admin engine. In the first app, we made the mistake of putting admin functionality in the \"normal\" pages. It was very enticing. We had that form already for the user to edit it. Just by changing the permissions, we could allow the admin to edit it, too. Forms are cheap and admins want extra fields. And more info. And basically a different UI.\r\n\r\nSo we can made an engine basically just like rails_admin did and gave it's own layout and views and JS and models and controllers, etc. Overall, we started treating our hardworking admins like we should: a customer with their own needs and dedicated experience.\r\n\r\nThe structure looked something like this...\r\n\r\n```\r\napp\r\n  assets\r\n  controllers\r\n  models\r\n    user.rb\r\n    post.rb\r\n  views\r\n    layouts\r\nadmin\r\n  app\r\n    assets\r\n    controllers\r\n    models\r\n      admin\r\n        user.rb\r\n        post.rb\r\n    views\r\n      layouts\r\nconfig\r\ndb\r\n  migrate\r\ngems\r\nspec\r\n```\r\n\r\nWhen we had this all mixed into one interface and set of models, at least a third of the code in a model like `Post` or `User` would be admin-specific actions. With this approach, we can give the admins a better, targeted experience and keep that code in admin-land.\r\n\r\nThroughout these engine discussions, the question of sharing code and/or inheriting from objects will keep coming up. Specifically, for the admin scenario, we say do whatever works for you and on a case by case basis. In the above approach, we would probably tend to have `Admin::Post < ::Post` and other such inheritance. In Rails 2, we probably wouldn't have done what as they would have different `attr_accessible` situations but that's happening in the controller these days, so now inheriting from them will just get the benefit of the data validations, which is something we definitely want to share.\r\n\r\nNote that inheriting is probably a bad choice if you have callbacks in the root model that you don't want triggered when the admin saves the record. In that case, it would be better to `Admin::Post < ActiveRecord::Base` and either duplicate the logic, have it only in SQL table (unique indexes for example), or have a mixin that is included in both.\r\n\r\n[back to top](#top)\r\n\r\n### Shared Code <a name=\"shared-code\"></a>\r\n\r\nThe note about controllers being in charge of the parameters involved leads to the next possibility. You can have your models (at least the ones you need to have shared) in the operator and all the other stuff in the engines. At this point, maybe you could add the `engines` namespace to be more clear.\r\n\r\n```\r\napp\r\n  models\r\n    user.rb\r\n    post.rb\r\nconfig\r\ndb\r\n  migrate\r\nengines\r\n  customer\r\n    app\r\n      assets\r\n      controllers\r\n      models\r\n        customer\r\n          something_admin_doesnt_use.rb\r\n      views\r\n        layouts\r\n  admin\r\n    app\r\n      assets\r\n      controllers\r\n      models\r\n        admin\r\n          admin_notes.rb\r\n      views\r\n        layouts\r\ngems\r\nspec\r\n```\r\n\r\nNow you can use `Post` from both and everything is just fine. This would work out well if it's mostly the data definition you are using and like to use things like decorators and/or service objects and/or fat controllers in your engines.\r\n\r\nYou could also put layouts or mixins in the operator. This might be a good idea if you were sharing the layout between two engines. At that point, maybe we'll just go all in on the engines by making a `shared` engine. Having a namespace for clarity is much simpler.\r\n\r\n```\r\napps\r\n  shared\r\n    app\r\n      assets\r\n      controllers\r\n        shared\r\n          authentication.rb\r\n      models\r\n        shared\r\n          post.rb\r\n          user.rb\r\n      views\r\n        shared\r\n          layouts\r\n  marketing\r\n    app\r\n      controllers\r\n        marketing\r\n          application_controller.rb\r\n          home_controller.rb\r\n  content\r\n    controllers\r\n    models\r\n      content\r\n        something_admin_doesnt_use.rb\r\n  admin\r\n    app\r\n      assets\r\n      controllers\r\n      models\r\n        admin\r\n          admin_notes.rb\r\n      views\r\n        layouts\r\nconfig\r\ndb\r\n  migrate\r\ngems\r\nspec\r\n```\r\n\r\nIn this structure, admin can still get it's own layout if it wants, but marketing and content can easily share the same layout in addition to the models.\r\n\r\nThe\r\n[example in Github](https://github.com/taskrabbit/rails_engines_example)\r\ntakes this just one step farther by not sharing models at all. Sharing the actual model can still lead to the\r\n[god model](http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/)\r\nsituation of a mono-Rails app without the use of other mitigating objects. To keep things as tight as possible, we've allowed each engine to have their own\r\n[User](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/apps/content/app/models/content/user.rb)\r\nobject, for example. If there is model code to share, it would still go in the shared engine, but as a mixin like\r\n[this one](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/apps/shared/app/models/shared/user/display.rb).\r\nNote that in a well-designed schema, only one of these actually writes to the database and the others include a `ReadOnly` module from the shared engine.\r\n\r\nThe repo's structure looks as follows:\r\n\r\n```\r\napps\r\n  shared\r\n    app\r\n      assets\r\n      controllers\r\n        shared\r\n          controller\r\n            authentication.rb\r\n      models\r\n        shared\r\n          model\r\n            read_only.rb\r\n          user\r\n            user_display.rb\r\n      views\r\n        shared\r\n          layouts\r\n  marketing\r\n    app\r\n      controllers\r\n        marketing\r\n          application_controller.rb\r\n          home_controller.rb\r\n        models\r\n          marketing\r\n            user.rb\r\n    db\r\n      migrate\r\n  account\r\n    app\r\n      controllers\r\n      models\r\n        content\r\n          user.rb\r\n          post.rb\r\n    db\r\n      migrate\r\n  content\r\n    app\r\n      assets\r\n      controllers\r\n      models\r\n        admin\r\n          post.rb\r\n          user.rb\r\n    db\r\n      migrate\r\n  admin\r\n    app\r\n      assets\r\n      controllers\r\n      models\r\n        admin\r\n          admin_notes.rb\r\n          post.rb\r\n          user.rb\r\n      views\r\n        layouts\r\n    db\r\n      migrate\r\nconfig\r\ngems\r\nspec\r\n```\r\n\r\n[back to top](#top)\r\n\r\n### API Server <a name=\"api-server\"></a>\r\n\r\nOur latest project at TaskRabbit basically looks the the above and the\r\n[example](https://github.com/taskrabbit/rails_engines_example)\r\nwith one difference: we don't share layouts between our engines. We've made the choice to have all the frontend code in one engine and all of the other engines just serve API endpoints. There are several shared mixins for these backend engines, but they don't need a layout because they are just using\r\n[jbuilder](https://github.com/rails/jbuilder)\r\nto send back JSON to the frontend client. The frontend engine, therefore, doesn't really use any models and has all the assets and such. Admin still has its own layout and uses a more traditional Rails MVC approach.\r\n\r\nIt looks like this:\r\n\r\n```\r\napps\r\n  shared\r\n    app\r\n      assets\r\n      controllers\r\n        shared\r\n          controller\r\n            authentication.rb\r\n      models\r\n        shared\r\n          model\r\n            read_only.rb\r\n          user\r\n            user_display.rb\r\n  frontend\r\n    app\r\n      assets\r\n      controllers\r\n        marketing\r\n          application_controller.rb\r\n          home_controller.rb\r\n        models\r\n          marketing\r\n            user.rb\r\n      views\r\n        frontend\r\n          layouts\r\n  account\r\n    app\r\n      controllers\r\n      models\r\n        content\r\n          user.rb\r\n          post.rb\r\n      views\r\n        account\r\n          users\r\n            show.json.jbuilder\r\n    db\r\n      migrate\r\n  content\r\n    app\r\n      controllers\r\n      models\r\n        admin\r\n          post.rb\r\n          user.rb\r\n      views\r\n    db\r\n      migrate\r\n  admin\r\n    app\r\n      assets\r\n      controllers\r\n      models\r\n        admin\r\n          admin_notes.rb\r\n          post.rb\r\n          user.rb\r\n      views\r\n        layouts\r\n    db\r\n      migrate\r\nconfig\r\ngems\r\nspec\r\n```\r\n\r\nThe API setup alleviates one of the odder things about the example approach. Ideally, there is no interaction between engines. Particularly in the models and views, this is critical. However, some knowledge leaks out in the example though the controllers. For example, the\r\n[login controller](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/apps/account/app/controllers/account/application_controller.rb#L11)\r\nredirects to `/posts` after login. This is in the content engine. It's probably not the end of the world but that is coupling. We get around this using our one frontend engine and the several API ones, but this does some serious commitment.\r\n\r\n[back to top](#top)\r\n\r\n## Strategies <a name=\"strategies\"></a>\r\n\r\nWe've gotten lots of questions and read about issues people are having with engines so let's go through them here.\r\n\r\n[back to top](#top)\r\n\r\n### Migrations and Models <a name=\"migrations-and-models\"></a>\r\n\r\nRails bills itself as \"convention over configuration\" so it's not too surprising to be confronted with lots of questions about \"where to put stuff\" when deviating (slightly) from the conventions. The one people seem the most worried about are migrations. We've never had an issue, but there must be scenarios that get a little tricky. If you are sharing the models, we would just put them in the normal `db/migrate` location. If your models live inside the engines, it's probably not a huge deal to still do that, but we've decided to have the migrations live with their models.\r\n\r\nAs notes, each model/table (say `users`) ideally has one master model. In the sample app, the `User` model's master is in the\r\n[account](https://github.com/taskrabbit/rails_engines_example/tree/434e687b795ec52705a3be1dd2c635f0054336d4/apps/account)\r\nengine. This engine is in charge of signing up and logging in users. Fleshed out, it would also be responsible for reseting a lost password and editing account information. It's the only `User` model that\r\n[mentions](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/apps/account/app/models/account/user.rb#L7)\r\n`has_secure_password` and knows anything about that kind of thing. The rest of the engines may\r\n[need](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/apps/content/app/models/content/user.rb#L5)\r\na `User` model but they have the `ReadOnly`\r\n[module](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/apps/shared/app/models/shared/model/read_only.rb)\r\nto prevent actually writing to the table.\r\n\r\nTherefore, the account engine has the\r\n[migrations](https://github.com/taskrabbit/rails_engines_example/tree/434e687b795ec52705a3be1dd2c635f0054336d4/apps/account/db/migrate)\r\nhaving to do with the users table. In order to register that migrations are within these engines, we\r\n[add](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/apps/account/lib/account/engine.rb)\r\na snippet like the following to each engine.\r\n\r\n```ruby\r\ninitializer 'account.append_migrations' do |app|\r\n  unless app.root.to_s == root.to_s\r\n    config.paths[\"db/migrate\"].expanded.each do |path|\r\n      app.config.paths[\"db/migrate\"].push(path)\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis (via\r\n[here](http://pivotallabs.com/leave-your-migrations-in-your-rails-engines/))\r\nputs the engine's migrations in the path. Migrations continue to work as they normally do with the timestamps and such. So our `db/migrate` folder doesn't have any files in it (and is not checked into git). I have one locally, just because when I make a migration, Rails creates it automatically. However, I end up doing something like this immediately.\r\n\r\n```bash\r\n$ bundle exec rails g migration CreatePosts\r\n      invoke  active_record\r\n      create    db/migrate/20140207011608_create_posts.rb\r\n$ mv db/migrate/20140207011608_create_posts.rb apps/content/db/migrate\r\n```\r\n\r\nYou might wonder, and it does come up, what to do when you are adding a column to the users table for some other feature in some other engine. For example, we added a boolean `admin` column to the example users table to know if the given user is allowed to do stuff in the admin engine. We see the notion of permissions as being within the account engine's scope, even if it's not being actively leveraged there. It's still part of the account. Therefore, we\r\n[added](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/apps/account/db/migrate/20140207164357_add_admin_to_users.rb)\r\nthe migration to the account engine.\r\n\r\nIn part, if I couldn't justify to myself why it would be part of the account engine, it would be a red flag. Specifically, should this even be in the users table at all. If the answer is \"yes\" for whatever reason, then I'd likely still put the migration in the account engine, but usually it helps me realize that it shouldn't be in the users table at all. A good example that came up in our app was the notion of profile. It seemed like it was 1-to-1 with users and what ever columns supported it should go in the users table. For a variety of reasons, including that we wanted a different engine for that, we ended up making it's own table with a a `has_one` relationship in that engine. This paid off even further as we realized that a `User` should actually have two profiles, one for their activity as a TaskPoster and one as a TaskRabbit, as they record and display very different information. Each has their own table and engine now.\r\n\r\nLet's say we wanted to cache the number of posts the user had made. That's a pretty clearcut case to use `counter_cache` and put a `posts_count` in the users table. We'll want to look closely at this situation. First of all, the `counter_cache` code would clearly go on the `User` model in the content engine. That would also require that model to not be read-only or at least not in spirit (depending on the specifics used to implement the feature). It's not a good feeling when you do all this architecture stuff and it gets in the way of something that is so easy and we have to look out for those cases. If this is one of those cases, just do it; literally, however you want. We would probably keep the migration in the account engine.\r\n\r\nIt might not be one of those cases, though. I have almost never been sorry when I've made another model in these cases. So we could make a `PostStatistic` model or something in the content engine which `belongs_to :user` for recording this (and likely other things that come up). The counter cache feature is not magic - we just increment that table as necessary. It also doesn't feel that superfluous as it exists only inside that engine (which. in turn, doesn't have all the random stuff internal to other engines). We have some tables that started out that way. Mostly because we actively try not to do JOINs on our API calls, these tables ending up being the hub of the most relevant data of what has happening in our marketplace. Another option that we've used in similar situations is not to make the column at all. The content engine, or whoever is using this kind of data, would use the timestamp of the last `Post` or some other data to use as the cache key to look up all kinds of stuff in a store like memcache or Redis. If it's not there, it will take bit the bullet and calculate it and store it in the cache.\r\n\r\nAgain, architecture does not exist for fun or to get in the way. If something is super-simple and obvious and easy to maintain while doing the \"right\" way for the design is difficult and fragile, we just do it the easy way. That's the way to ship things for customers. However, we've found that in most case the rules of the system kick off useful discussions and behaviors that tend to work out quite well.\r\n\r\n[back to top](#top)\r\n\r\n### Admin <a name=\"admin\"></a>\r\n\r\nOne of the cases where it's important to really examine the value and return on investment in engine separation is with the admin engine. We believe it's a special case.\r\n\r\nIn our system, the admin engine has it's own migrations. For example, we have a model called `AdminNote` where an admin can jot down little notes about most objects in the system. It clearly owns that. But the reason this whole experience exists in the first place is that it also is able to write more or less whatever it wants to _all_ the objects in the system. This clearly violates our single-model-master rule. So we don't fight an uphill battle here by making a special case and saying that the admin engine can literally do whatever it wants. All the other engines live in complete isolation from each other for a variety of reasons. Admin can depend directly on any or all of them. It's at the top of the food chain because it needs to regulate the whole system.\r\n\r\nSo it's\r\n[fine](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/apps/admin/app/models/admin/post.rb)\r\nif `Admin::Post < Content::Post` or just uses `Content::Post` directly in it's controllers. It's just not worth it to share all of the data definitions and validations with when it will almost always be with engine X and admin. Note that it's important to have the same validations because admin might be in charge, but it still needs to produce valid data as that other engine will be using it.\r\n\r\nIn our much larger app, we inherit from and/or use most of the models in the system as well as service objects from other engines. We do not use outside controllers or views. Our admin engine does use it's own layout and much simpler request cycle than our much fancier frontend app. We tried to show the admin engine using a different layout in the example app, but they're both bootstrap so it might be hard to tell. The header is red in admin :-)\r\n\r\n[back to top](#top)\r\n\r\n### Assets <a name=\"assets\"></a>\r\n\r\nEveryone seems to have struggled with this one and I can't even imagine pulling apart assets if they weren't coded in a modular way at the start. However, starting with them separate in Rails 4 has been fairly straightforward. We add the following\r\n[code](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/apps/account/lib/account/engine.rb)\r\nto our engine much like the migration code.\r\n\r\n```ruby\r\ninitializer 'account.asset_precompile_paths' do |app|\r\n  app.config.assets.precompile += [\"account/manifests/*\"]\r\nend\r\n```\r\nYou could list all the manifests one by one, but we've found that it's simpler to just always put them in a folder created for the purpose. This works for both css and js. You would would reference those files something like this:\r\n\r\n```ruby\r\n= stylesheet_link_tag 'account/manifests/application'\r\n= javascript_include_tag 'account/manifests/application'\r\n```\r\n\r\n[back to top](#top)\r\n\r\n### Routes <a name=\"routes\"></a>\r\n\r\nIn an Engine, routes go within the engine directory at the\r\n[same](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/apps/account/config/routes.rb)\r\n`config/routes.rb` path. It's important to note here that in order for these routes to be put into use in the overall app, the engine needs to be mounted. In a normal engine use case, you would mount rails_admin (say to /admin) to give a namespace in the url, but we think it's important that all of these engines get mounted at the root level. You can see our root routes.rb file\r\n[here](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/config/routes.rb).\r\n\r\n```ruby\r\nRailsEnginesExample::Application.routes.draw do\r\n  BootInquirer.each_active_app do |app|\r\n    mount app.engine => '/', as: app.gem_name\r\n  end\r\nend\r\n```\r\n\r\nSo as expected, the operator app has no routes of it's own and it's all handled by the engines. I'll add little more about the `BootInquirer` in a bit. It is just a helper class that knows all the engines. This means that the code is functionally something more like this:\r\n\r\n```ruby\r\nRailsEnginesExample::Application.routes.draw do\r\n  mount Admin::Engine     => '/', as: 'admin'\r\n  mount Account::Engine   => '/', as: 'account'\r\n  mount Content::Engine   => '/', as: 'content'\r\n  mount Marketing::Engine => '/', as: 'marketing'\r\nend\r\n```\r\n\r\nIt would really clean to have something other than root in these mountings, but it doesn't seem practical or that important. We want to be able to have full control over our url structure. For example, mounting the account engine at anything but root would prevent it from handling both the `/login` and `/signup` paths. The trade-off is that two engines could claim the same URLs and conflict with much confusion. That's something we can manage with minimal effort. We've found that most engine route files start with `scope` to put most things under one directory or a few `resources` which does basically the same thing.\r\n\r\nAnother important note is to\r\n[use](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/apps/account/lib/account/engine.rb#L3)\r\n`isolate_namespace` in your Engine declaration. That prevents various things like helper methods from leaking into other engines. This makes sense for our case because the whole point is to stay contained. Another side effect is route helpers like 'posts_path' to work as expected without needing to prefix them like `content.posts_path` in your views. I believe it might also make the parameters more regular (for example having `params[:post]` instead of `params[:content_post]`). Oh, just put it in\r\n[there](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/apps/admin/lib/admin/engine.rb).\r\n\r\n[back to top](#top)\r\n\r\n### Tests <a name=\"tests\"></a>\r\n\r\nMany of the issues noted\r\n[here](http://pivotallabs.com/experience-report-engine-usage-that-didn-t-work/)\r\nrevolve around testing. One of the promises of engines is the existence of the subcomponents that you could (theoretically) use in some other app. This is not the goal here. We are using engines maximize local simplicity in our application, not create a reusable library. To that end, we don't think the normal Engine testing mechanism of creating a dummy app within the engine is helpful.\r\n\r\nOn our first engine application, we put a `spec` folder within each engine and then wrote a `rspec_all.sh` script to run each of them. It was not the right way. To do that really correctly, you'd test at that level and you'd have to test again at the integration level. This is another case of it not being worth it. Now we just put all our specs in the spec\r\n[directory](https://github.com/taskrabbit/rails_engines_example/tree/434e687b795ec52705a3be1dd2c635f0054336d4/spec) and run `rspec spec` to run them all.\r\n\r\nEach engine has it's own directory in there to keep it somewhat separate and to be able to easily test all of a single engine and it ends up looking like a normal app's root spec folder with models, requests, controllers, etc. Much like the admin engine, there are no rules about what you can and can't use in the tests. The goal is make sure the code is right, not to follow some architectural edict. For example, in a test that checks whether a Task can be paid for, it's fine to use the models from the payment engine to make sure everything worked together well.\r\n\r\nOne thing that is interesting is\r\n[fixtures](http://api.rubyonrails.org/v3.2.13/classes/ActiveRecord/Fixtures.html).\r\nWe like using fixtures because it's a pretty good balance between speed and fully executing most of the code in out tests. We use\r\n[fixture_builder](https://github.com/rdy/fixture_builder)\r\nto save the hassle of maintaining those yml files precisely. Anyway, the issue in the case where we have multiple engine's each with their own model class is that fixtures (and\r\n[factories](https://github.com/thoughtbot/factory_girl)\r\nfor that matter) only get one class. So if you do something like this while testing in the content engine, you'd be in trouble:\r\n\r\n```ruby\r\ndescribe Content::Post do\r\n  fixtures :users\r\n\r\n  it \"should be associated with a user\" do\r\n    user = users(:willy)\r\n    post = Content::Post.new(content: \"words\")\r\n    post.user = user\r\n    post.save.should == true\r\n    user.posts.count.should == 1\r\n  end\r\nend\r\n```\r\n\r\nThis is a problem because of classes expecting to be a certain type. You'd get this error:\r\n\r\n```bash\r\nFailures:\r\n\r\n  1) Content::Post should be associated with a user\r\n     Failure/Error: post.user = user\r\n     ActiveRecord::AssociationTypeMismatch:\r\n       Content::User(#70346317272500) expected, got Account::User(#70346295701620)\r\n```\r\n\r\nSo the user has to be an instance of the `Content::User` and not an `Account::User` class. We use a\r\n[helper](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/spec/support/fixture_class_name_helper.rb)\r\nto say what the classes are as well as switch between them. So this test will use the correct classes:\r\n\r\n```ruby\r\ndescribe Content::Post do\r\n  fixtures :users\r\n\r\n  it \"should be associated with a user\" do\r\n    user = fixture(:users, :willy, Content)\r\n    post = Content::Post.new(content: \"words\")\r\n    post.user = user\r\n    post.save.should == true\r\n    user.posts.count.should == 1\r\n  end\r\nend\r\n```\r\n\r\nThe same sort of thing could be done with FactoryGirl too. Often, we end up just using the ids more than we would in a normal test suite. The important thing to note is to just do whatever you feel gives you the best coverage with the most return on investment for your time.\r\n\r\n[back to top](#top)\r\n\r\n### Memory <a name=\"memory\"></a>\r\n\r\nYou may have noticed the\r\n[BootInquirer](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/lib/boot_inquirer.rb)\r\nclass mentioned earlier. This is a class that know about all the engines in the system.\r\n\r\n```ruby\r\n  APPS = {\r\n      'a' => 'account',\r\n      'c' => 'content',\r\n      'm' => 'marketing',\r\n      'z' => 'admin'\r\n    }\r\n```\r\n\r\nIt is called from three places.\r\n\r\n```ruby\r\n# Gemfile\r\ngemspec path: \"apps/shared\"\r\nBootInquirer.each_active_app do |app|\r\n  gemspec path: \"apps/#{app.gem_name}\"\r\nend\r\n\r\n# application.rb\r\nrequire_relative \"../lib/boot_inquirer\"\r\nBootInquirer.each_active_app do |app|\r\n  require app.gem_name\r\nend\r\n\r\n# routes.rb\r\nBootInquirer.each_active_app do |app|\r\n  mount app.engine => '/', as: app.gem_name\r\nend\r\n```\r\n\r\nThe main point here is to simplify even further how to add a new engine to the app. The secondary point is somewhat interesting, though. One of the potential downsides of an engine-based app, over multiple apps, is the larger memory footprint (or larger scale production rollout) of some obscure and complicated native library for just one of the engines. This would not be a problem if you could \"boot\" the app with the just _some_ of the engines enabled. The `BootInquirer` makes that possible. It inspects and environment variable to know which engines to add to the gemspec and require and route towards.\r\n\r\n```\r\n$ ENGINE_BOOT=am bundle exec rails c\r\n    => will boot the account and marketing engines - but not content, admin, etc.\r\n$ ENGINE_BOOT=-m bundle exec rails c\r\n    => will boot all engines except marketing\r\n```\r\n\r\nWe haven't actually seen memory be that different that in our large Rails app. In fact, it is less because of a combination of Ruby upgrades and less conspicuous gem consumption. However, memory-wise this setup allows us to use our one codebase like multiple apps. In that case, we use a load balancer to map url paths to the correct app.\r\n\r\nThis is also useful in processing background workers. You would likely get an extra Resque worker or two. It's important to have a good queue strategy (different queues per engine) and to really not have the engines depend on each other to make this work, of course.\r\n\r\nIn order for this to work, we need to be more mindful of our gem usage. The first step is changing\r\n[application.rb](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/config/application.rb#L7)\r\nto say `Bundler.setup(:default, Rails.env)` instead of `Bundler.require(:default, Rails.env)` as usual. This mean we will have to explicitly require the gems we are using instead of it happening automatically. Most of those dependencies are in the engines' gemspecs and they'd have to be required anyway. However, by changing this line, we'll have to require what is needed from the main Gemfile as well. Ideally, there wouldn't be anything in\r\n[there](https://github.com/taskrabbit/rails_engines_example/blob/434e687b795ec52705a3be1dd2c635f0054336d4/Gemfile) at all, but we have some Rails and test stuff that all the engines use.\r\n\r\nYou may notice that the exception we made for the admin engine rears its head here. If admin depends on the other engines, you won't be able to use admin experience unless you launch the app with all those engines. This is definitely true. The servers that the admin urls route to will have to have all of the engines running. We found it was useful to quarantine admin usage anyway as there are a few requests and inputs that could blow out the heap size fairly easily.\r\n\r\n[back to top](#top)\r\n\r\n### Folders and Files <a name=\"folders-and-files\"></a>\r\n\r\nIf you're interested in this setup, you're just going to have to get used to it. There are a lot of directories. There are lot of files named the same thing. I've found that Sublime Text is better for this than Textmate. I'm a huge fan of âŒ˜T to open files and Sublime allows the use of the directory names in that typeahead list. If your editor doesn't do this, then you'll spend more time than you want to look through the six different `user.rb` or `application_contoller.rb` files in the project.\r\n\r\n[back to top](#top)\r\n\r\n### Interaction Between Engines <a name=\"interaction-between-engines\"></a>\r\n\r\nSo we've gone through a lot of trouble to keep that shiny new Rails app feel. Each engine has a particular goal in life and everything is nice and simple. Particularly in the API case, it writes and reads its data and generally just takes of business. But the world isn't always perfect and sometimes the engines need to talk to each other. If it's happening too much, we probably didn't modularize along the right lines and we should consider throwing them together. We don't have all the answers, but engine naming and scoping seems to be a fine art. It's very tempting to go very narrow for cleanliness and it's also very tempting to just throw stuff in to an existing one so I'm not surprised when we find that the lines are a not drawn quite right.\r\n\r\nThere are other cases, though, that are not systemic errors in engine-picking and future-prediction. It's the kind of case I talked about with the `posts_count` above. Let's say we had a good reason to make that happen. Actually let's change it just a little bit to be more realistic. Let's say we had a profile engine where user could manage his online presence. Let's also say that other users could see and rate his posts. It's a completely reasonable thing to have an average post rating shown on his profile. Does this data about posts mean that the profile pages or API should be part of the content engine? We don't think so. This is likely just one tiny detail in an engine otherwise setup to upload photos, quote favorite movies, or whatever. We just need a little average rating on the there somewhere with a link to the posts.\r\n\r\nIn this case, we use our\r\n[Resque Bus](https://github.com/taskrabbit/resque-bus)\r\ngem extensively. This is a minor add-on to\r\n[Resque](https://github.com/resque/resque/blob/1-x-stable/README.markdown)\r\nthat changes the paradigm just enough to allow us to decouple these engines. In a normal Rails apps using Resque, we would queue up a background worker to process the rating. This worker would calculate the new average rating and store it in the profile. Resque Bus uses publishing and subscription to accomplish similar goals. If you buy into this model, you have all of your engines and in this case the content engine, publishing to the bus when interesting things happen. Creation of a post or rating would be a good example. Other engines (or completely separate apps) then subscribe to events they find interesting. There can be more than one subscriber. Even when there is nothing particularly interesting to do, we've found that always having a subscriber to record the event produces a really useful log. In the rating case, though, the profile engine would also subscribe to the event and record the new rating. By one engine simply noting that something happened and the other reacting to the occurrence, we maintain the conceptual as well as physical (these engines could be on different servers) decoupling.\r\n\r\nWhat exactly gets published and how that is used is up to the developers involved. There seems to be a few options in this specific case.\r\n\r\nA) The content engine is publishing data changes. `ResqueBus.publish('post_rated', {post_id: 42, author_id: 2, rated_by: 4, rating: 4})`\r\nB) The content engine adds some calculations. `ResqueBus.publish('post_rated', {post_id: 42, author_id: 2, rated_by: 4, rating: 4, new_average: 4.25, total_ratings: 20})`\r\n\r\nChoosing option B is interesting for a few reasons:\r\n\r\n* It is predicting the information other engines will want to know.\r\n* It decreases the coupling because now the profile engine now just records the info instead of having to calculate it.\r\n* It creates a record of the averages in our event store. Maybe we'll draw a graph of it sometime.\r\n* It adds to the time required to complete the request to create the rating.\r\n\r\nThis would mean the post engine would have something like this in an initializer:\r\n\r\n```ruby\r\nResqueBus.dispatch('profile') do\r\n  subscribe 'post_rated' do |attributes|\r\n    profile = Profile::Document.find_by(user_id: attributes['author_id'])\r\n    profile.post_ratings_total  = attributes['total_ratings']\r\n    profile.post_rating_average = attributes['new_average']\r\n    profile.save!\r\n  end\r\nend\r\n```\r\n\r\nOr in the way that we prefer using a subscriber class that we would put in `profile/app/subscribers`:\r\n\r\n```ruby\r\nclass Profile::ContentSubscriber\r\n  include ResqueBus::Subscriber\r\n\r\n  subscribe :post_created\r\n\r\n  def post_created(attributes)\r\n    profile = Profile::Document.find_by(user_id: attributes['post_author_id'])\r\n    profile.post_ratings_total  = attributes['total_ratings']\r\n    profile.post_rating_average = attributes['new_average']\r\n    profile.save!\r\n  end\r\nend\r\n```\r\n\r\nIt's clearly a fine option and the added time probably isn't too much assuming we have the right indexes on our database, but we actually tend to use option A. We don't particularly like trying to predict which events are interesting and how other engines will use them so we just publish on all creations or updates. We are fine with the profile engine having read-only `Rate` model and code to calculate the average. It could keep a running tally of the total number and just add this one to it, but we tend to recalculate it every time because it's not that hard and is less fragile.\r\n\r\nIt would look something like this:\r\n\r\n```ruby\r\nclass Profile::ContentSubscriber\r\n  include ResqueBus::Subscriber\r\n\r\n  subscribe :post_rated\r\n\r\n  def post_rated(attributes)\r\n    total = Profile::Rate.where(author_id: attributes['author_id']).count\r\n    sum   = Profile::Rate.where(author_id: attributes['author_id']).sum(:rating)\r\n\r\n    profile = Profile::Document.find_by(user_id: attributes['post_author_id'])\r\n    profile.post_ratings_total  = total\r\n    profile.post_rating_average = sum.to_f / (5*total.to_f)\r\n    profile.save!\r\n  end\r\nend\r\n```\r\n\r\nHowever you do it, the point is that this engine is working on it's own for it's own purposes. Layering it on, it's quite straightforward to see how we could build spam detection as its own engine or into the admin one. We could subscribe to ratings or post creation and react accordingly, maybe pulling the post or giving the user a score that limits his visibility, etc. Or we could add a metrics engine, to report the conversion of a user on his first post to a variety of external services. Then, when a new developer starts and asks where the metrics code is, we don't have to say what we said before which was, \"everywhere.\" We could show very simple mappings between things that are happening throughout the system and the numbers like revenue or engagement that are getting reported to something like Google Analytics.\r\n\r\n[back to top](#top)\r\n\r\n## Summary <a name=\"summary\"></a>\r\n\r\nTry out engines. We like them.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}